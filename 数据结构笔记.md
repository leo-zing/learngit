# 绪论

## （a）计算

​		计算既是数据结构的研究对象（研究在计算的过程中所蕴含的本质的内在规律，以及典型的技巧），也是最终的研究目的和目标（实现有效的、高效的计算）。甚至可以扩展到整个计算机科学。

​		**计算机只是我们的一个工具和手段，而计算才是我们不应忘记的最终目的和目标。**

​		例子：  绳索计算机（过直线一点作其垂线）
​					尺规计算机（在给定的一条线段找到两个分点，使得一条线段均匀分为三条）

- 计算 = 信息处理
  借助某种工具，遵照一定规则，以明确而机械的形式进行

- 计算模型 = 计算机 = 信息处理工具
  所谓算法，即特定计算模型下，旨在解决特定问题的指令序列
  			**输入**		待处理的信息（问题）
  			**输出**		经处理的信息（答案）
  		**正确性**		的确可以解决指定的问题 		 *但在实际情况中这条不是每次都能证明*
  		**确定性**		任一算法都可以描述为一个由基本操作组成的序列
  		**可行性**		每一基本操作都可以实现，且在常数时间内完成
  		**有穷性**		对于任何输入，经有穷次基本操作，都可以得到输出

  

  例：序列
  $$
  Hailstone(n) = 
  \begin{cases}
  	\{1\} & n\leq 1\\
  	\{n\}\bigcup Hailstone(n/2) & \text n偶\\
  	\{n\}\bigcup Hailstone(3n+1) & \text =奇\\
  \end{cases}
  $$
  ```c++
#include <iostream>
  using namespace std;
  
  int Hailstone(int n){
    cout <<n <<", ";
      int length = 1;
      while(1 != n){
          if(n % 2)
              return length + Hailstone(3 * n + 1);
          else
              return length + Hailstone(n / 2);
      }
      return 1;
  }
  
  int main()
  {
      cout <<"Hailstone(n) =";
      int length = Hailstone(42);
      cout <<endl <<"一共有" <<length <<"个元素" <<endl;
      return 0;
  }
  ```
  
  Hailstone(42) = {42 , 21 , 64 , 32, ... ,1} 																				9
  Hailstone(7) = {7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1}					 	17
  Hailstone(27) = {27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, ... , 1}					  112
  
  但对于任意的n，总有
  $$
  |Hailstone(n)| < \infty \ ?
  $$
  目前这个问题还没有确切的结论，也就是说我们既不能证明对于任何的n，这个序列都必然是有穷的，也不能找到一个反例。因此这段**程序未必是算法**。
  $$
  程序 \not= 算法
  $$

我们的问题：在正确性确定性可行性包括有穷性都基本上确定了之后，如何能够设计优化出更好的一个计算过程，一个对应的数据结构和对应的算法？

但什么样的算法才是好的数据结构，好的计算过程呢？

### 好算法

1. 正确：符合语法，能够编译、链接
   $$
   能够正确处理
   \begin{cases}
   简单的\\
   大规模的\\
   一般性的\\
   退化的\\
   任意合法的\\
   \end{cases}
   \ 输入
   $$



2. 健壮：能辨别不合法的输入并做适当处理，而不致非正常退出

3. 可读：结构化 + 准确命名 + 注释 + ···

4. **效率：速度尽可能快；存储空间尽可能少**——这才是我们最关心的问题
   $$
   Algorithms\ +\ Data\ Structures\ =\ Programs	\ \ \ \ \ \ \ \ \ //N.Wirth, 1976\\
   (Algorithms\ +\ Data\ Structures)\ *\ Efficiency\ =\ Computation
   $$

## (b)计算模型

1. 引入理想、统一、分层次的尺度
2. 运用该尺度，以测量DSA的性能

这里的测量测度实际上是算法分析的范畴。

### 算法分析

- 两个主要方面：

  1. 正确性：算法功能与问题要求一致？
     				数学证明往往非常困难...因此不是数据结构的重点

  2. 成本：运行时间 + 所需存储空间
                 如何度量？如何比较？

- 考察：T<sub>A</sub>(P) = 算法A求解问题实例P的计算成本
  意义不大，毕竟...可能出现的问题实例太多，如何归纳概括？

- 观察：问题实例的<font color=#ff0000>规模</font>,往往是决定计算成本的主要因素  <!--大体来说是这样的-->

- 通常：规模接近，计算成本也接近
              规模扩大，计算成本亦上升

  - #### 特定算法 + 不同实例

    - 令T<sub>A</sub>(n) = 用算法A求解某一问题规模为n的实例，所需的计算成本
      讨论特定算法A(及其对应的问题)时，简记作T(n)

    - 然而，这一定义仍有问题

    - 观察：同一问题等规模的不同实例，计算成本不尽相同，甚至有实质差别

    - 例如：在平面上的n个点中，找到所成三角形面积最小的三个点

      ​           以蛮力算法为例，最坏情况下需枚举所有C(n,3)种组合
      ​			但运气好的话，第一次就找到了

    - **<font color = #ff0000>稳妥起见，在规模同为n的所有实例中，只关注最坏（成本最高）者</font>**

  - #### 特定问题 + 不同算法

    - 同一问题通常有多种算法，如何评判其优劣？

    - 实验统计是最直接的方法，但足以准确反映算法的真正效率？

    - 不足够！
      $$
      不同的算法
      \begin{cases}
      可能更适应于不同规模的输入\\
      可能更适应于不同类型的输入\\
      \end{cases}
      $$

      $$
      同一算法
      \begin{cases}
      可能由不同程序员、用不同程序语言、经不同编译器实现\\
      可能实现并运行于不同的体系结构、操作系统...\\
      \end{cases}
      $$

    - 为给出客观的评判，需要抽象出一个理想的平台或模型
                    不再依赖于上述种种具体的因素
                    从而直接而准确地描述、测量并评价算法

  - #### 图灵机（Turing Machine）

    - Tape	依次均匀地划分为单元格，各注有某一字符，默认为‘#’

    - Alphabet字符的种类有限

    - Head    总是对准某一单元格，并可读取和改写其中的字符；每经过一个节拍，可转向左侧或右侧的邻格

    - State      TM总是处于有限种状态中的某一种，每经过一个节拍，可（按照规则）转向另一种状态

    - Transition Function(q, c; d, L/R, p)
                 若当前状态为q且当前字符为c，则将当前字符改写为d；转向左侧/右侧的邻格；转入p状态；一旦转入特定的状态'h'，则停机

    - ##### 图灵机实例

      ![](assets/捕获.PNG)

    - ##### RAM: <u>Random Access Machine</u>

      ![](assets/捕获-1563632028640.PNG)

    - RAM实例
      ![](assets/捕获-1563632363022.PNG)

      执行过程可以记录为一张表
      表的行数即是所执行基本指令的总条数
      能够客观度量算法的执行时间

    - **图灵机、RAM等模型为度量算法性能提供了准确的尺度**

## c)大O记号

渐进分析：在问题规模足够大后，算法
					需执行基本操作次数：T(n) = ?
					需占用的存储单元数：S(n) = ?															<font color = #0000ff>通常不考虑</font>

#### 大o记号(big-o notation)：

​				T(n) = of(n))   if  存在c > 0，当n >> 2后，有T(n) < c · f(n)
例：
$$
\sqrt{5n*[3n*(n+2)+4]+6}<\sqrt{5n*[6n^2+4]+6}<\sqrt{35n^3+6}<6n^{1.5}=o(n^{1.5})
$$
与T(n)相比，f(n)更为简洁，但依然反映前者的增长趋势
			<font color=#ff0000>常系数可忽略，低次项可忽略</font>

<font color=#ff0000>O(1) < O(log*n*) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(2<sup>n</sup>) </font>

 #### 大Ω记号(big-Ω notation):

​				T(n) = Ω(f(n)) 	存在c > 0，当n >> 2后，有T(n) > c · f(n)

#### 大θ记号(big-θ notation)：

​				T(n) = θ(f(n))	当n >> 2后，有c<sub>1</sub>·f(n) > T(n) > c<sub>2</sub>·f(n)

 ![](assets/捕.PNG)