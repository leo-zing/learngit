# 递归问题

## 1.1 河内塔

1883年  爱德华·卢卡斯[法]

给定一个由8个圆盘组成的塔，这些圆盘按照大小递减的方式套在三根桩柱中的一根上。我们的目的是要将整个塔移动到另一根桩柱上，**每次只能移动一个圆盘，且较大的圆盘在移动过程中不能放置在较小的圆盘上面**。

![河内塔](C:\Users\cqjtu\Pictures\河内塔.png)

解：令$T_n$是根据卢卡斯规则将n个圆盘从一根桩柱移动到另一根桩柱所需要的最少移动次数。
		那么显然有$T_0=0、T_1=1、T_2=3$

​		移动3个圆盘的思路：先把上面两个圆盘移动到中间的桩柱上，然后移动第三个圆盘，接着再把其余两个放到		它上面。
​		这个方法可以推广到n个圆盘：首先把上面的$n-1$个小圆盘移动到一个不同的桩柱上(需要$T_{n-1}$次移动)，然		后移动最大的圆盘(需要一次移动)，最后再把那$n-1$个小圆盘移回到最大圆盘上面(这需要另外的$T_{n-1}$次移		动)。这样，至多需要$2T_{n-1}+1$次移动就能移动$n(n>0)$个圆盘了：
$$
T_n\leq2T_{n-1}+1，n>0
$$
​		又因为我们迟早必须移动最大的那个圆盘。当我们这样做时，那$n-1$个小圆盘就必须已经在某根桩柱上，而		这至少需要$T(n-1)$次移动才能把它们放置到那儿。移动最大的圆盘只需一次，但之后需要把那$n-1$个小圆		盘(它们必须仍然在同一根桩柱上)移回到最大圆盘上面，这也需要$T_{n-1}$次移动。从而：
$$
T_n\geq2T_{n-1}+1，n>0
$$
​		把这两个不等式与$n=0$时的平凡解结合在一起就得到**递归式**：
$$
\begin{align}
T_0=&0;\\
T_n=&2T_{n-1}+1,n>0.
\end{align}
$$
1. 求得**封闭形式**的解的一种方法时猜出正确的解，然后证明我们的猜想时正确的。

$$
\begin{align}
T_0=&0\\
T_1=&1\\
T_2=&3\\
T_3=&2\times3+1=7\\
T_4=&2\times7+1=15\\
T_5=&2\times15+1=31\\
T_6=&2\times31+1=63
\end{align}
$$
​		这看起来肯定像是$T_n=2^n-1，n\geq0$，至少这对$n\leq6$是成立的。

​		接下来使用**数学归纳法**：
$$
其基础是显然的，因为T_0=2^0-1=0.\\而如果我们假设当n被n-1取代时T_n=2^n-1，n\geq0成立\\
则对n>0用归纳法就得出：\\T_n=2T_{n-1}+1=2(2^{n-1}-1)+1=2^n-1\\
从而式子对n也成立。
$$

  2. 求**封闭形式**的解的另一种方法：
     把递归式中方程的两边加上1可得到：
     $$
     \begin{align}
     T_0+1=&1;\\
     T_n+1=&2T_{n-1}+2,n>0.
     \end{align}
     $$
     现在令$U_n=T_n+1$，那么就有：
     $$
     \begin{align}
     U_0=&1;\\
     U_n=&2U_{n-1},n>0.
     \end{align}
     $$
     现在很明显就可以看出解正是$U_n=2^n$，从而有$T_n=2^n-1$。

## 1.2 平面上的直线

用一把比萨刀直直地切n刀，可以得到多少块比萨饼？或者说得更有学术味儿点：平面上n条直线说界定的区域的最大个数$L_n$是多少？这个问题于1826年被一位瑞士数学家$斯坦纳^{338}$首先解决。

解：记住，首先研究所有情形中之最小者。
		没有直线的平面有1个区域；有一条直线的平面有2个区域；有两条直线的区域有4个区域。
![平面上的直线](具体数学.assets/平面上的直线.png)

首先一定会想到$L_n=2^n$，当然！增加一条新的直线直接使区域的个数加倍，遗憾的是，这是<font color="red">错误的</font>。

因为，如果第n条直线能把每个已有区域分为两个，那么就能加倍。它肯定能把一个已有区域至多分成两个，这是因为每个已有区域都是凸的(**一条直线可以把一个凸区域分成至多两个新区域，这些新的区域也将是凸的**)。但是当增加第三条直线时，我们很快发现，不论怎样放置前面两条直线，它只能至多分裂3个已有的区域：
      										![1567821923962](具体数学.assets/1567821923962.png)
从而$L_3=4+3=7$是我们能做到的最好结果。

略加思考之后，我们可以给出适当的推广：第$n(n>0)$条直线使得区域的个数增加k个，当且仅当它对k个已有区域进行了分裂；而它对k个已有区域进行分裂，当且仅当它在$k-1$个不同的地方与前面那些直线相交。两条直线至多相较于一点，因而这条新的直线与那$n-1$条已有直线至多相交于$n-1$个不同的点，故必定有$k\leq n$。我们就证明了上界：
$$
L_n\leq L_{n-1}+n,n>0.
$$
此外，用归纳法容易证明这个公式中的等号可以达到。我们径直这样来放置第n条直线，使得它不与其他直线中的任何一条平行(从而它与它们全部相交)，且它不经过任何已经存在的交点(从而它与它们全都在不同的点相交)。于是该递归式即为：
$$
\begin{align}
L_0=&1;\\
L_n=&L_{n-1}+n,n>0.
\end{align}
$$
现在求封闭式的解：因$1、2、4、7、11、17····$看起来并不熟悉，故而另辟蹊径。
我们常常可以通过将它从头到尾一直“展开”或者“解开”来弄清楚递归式，如下：
$$
\begin{align}
L_n=&L_{n-1}+n\\
=&L_{n-2}+(n-1)+n\\
=&L_{n-3}+(n-2)+(n-1)+n\\
\vdots\\
=&L_0+1+2+\cdots+(n-2)+(n-1)+n\\
=&1+S_n,其中S_n=1+2+3+\cdots+(n-1)+n.
\end{align}
$$
换句话说，$L_n$比前n个正整数的和$S_n$大1。

**三角形数**：

|    n    |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |  12  |  13  |  14  |
| :-----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $S_{n}$ |  1   |  3   |  6   |  10  |  15  |  21  |  28  |  36  |  45  |  55  |  66  |  78  |  91  | 105  |

为计算$S_n$，我们利用据说高斯在1786年想的一个技巧，那时他只有9岁
(阿基米德也曾在他关于螺旋线的经典著作的命题10和命题11中用到过)：
$$
\begin{align}
S_n=&1&+&2&+&3&+&\cdots&+&(n-1)&+&n\\
+S_n=&n&+&(n-1)&+&(n-2)&+&\cdots&+&2&+&1\\
\Rightarrow2S_n=&(n+1)&+&(n+1)&+&(n+1)&+&\cdots&+&(n+1)&+&(n+1)
\end{align}
$$
简化即得：
$$
S_n=\frac{n(n+1)}2,n\geq0,
$$
好的，我们就有解答：
$$
L_n=\frac{n(n+1)}2+1,n\geq0.
$$
我们再使用归纳法做一个严格的证明：
$$
\begin{align}
&当n=0，1，2时，L_n显然成立；\\
&令n=k时，L_n也成立；\\
&则n=k+1时有：\\
&L_{k+1}=L_k+k+1=\frac{k(k+1)}2+1+k+1=\frac{(k+1)(k+2)}2+1.
\end{align}
$$


**<font color="red">延伸：</font>**
现在我们谈谈平面上直线问题的一个变形：假设我们用折线代替直线，每一条折线包含一个“锯齿”。平面上由n条这样折线所界定的区域的最大个数$Z_n$是多少？
解：同样从这些小的情形出发：
![1567835878549](具体数学.assets/1567835878549.png)
我们意识到：除了这“两条”直线不经过它们的交点延伸出去使得区域相融合之外，一条折线与两条直线类似：

![1567836162559](具体数学.assets/1567836162559.png)

当我们放置得当——锯齿点必须放在它与其它直线的交点“之外”，也就是说，对每条折线我们仅仅失去两个区域：
$$
Z_n=L_{2n}-2n=\frac{2n(2n+1)}2+1-2n\\
=2n^2-n+1,n\geq0.
$$
比较两者，我们发现对于大的n有：
$$
L_n\sim\frac12n^2,\\
Z_n\sim2n^2;
$$
所以用折线所能得到的区域是用直线所能得到的区域的大约4倍。

## 1.3 约瑟夫问题

以夫拉维·约瑟夫(一世纪著名历史学家)
在犹太罗马战争期间，它们41名犹太反抗者困在了罗马人包围的洞穴中。这些反抗者宁愿自杀也不愿被活捉，于是决定围成一个圆圈，并沿着圆圈每隔两个人杀死一个人，知道剩下最后两个人为止。但是，约瑟夫和一个未被告发的同谋者不希望无谓地自杀，于是他迅速计算出他和其朋友在这个险恶的圆圈中应该站的位置。

我们这个问题略有变化，从围成标有记号1到n的圆圈的n个人开始，每隔一个删去一个人，直到只有一个人幸存下来。例如n=10的起始图形：

​                                                                  ![1567899133448](具体数学.assets/1567899133448.png)

消去的顺序是：2，4，6，8，10，3，7，1，9，于是5幸存下来。问题：确定幸存者的号码$J(n)$。

解：同样先研究小的情形：

|    n    |  1   |  2   |  3   |  4   |  5   |  6   |
| :-----: | :--: | :--: | :--: | :--: | :--: | :--: |
| $J(n) $ |  1   |  1   |  3   |  1   |  3   |  5   |

似乎$J(n)$总是奇数。事实上，对此有一个好的解释：绕这个圈走第一圈就消除了所有的偶数号码。

对于n是偶数的情形：
不妨假设一开始有$2n$个人。经过第一轮后剩下的是：
																![1567899925696](具体数学.assets/1567899925696.png)

3号是下一个要离开的人。除了每个人的号码加倍并减去1之外，这正像对n个人开始时的情形。就是说：
$$
J(2n)=2J(n)-1，n\geq1.
$$
对于n是奇数的情形：
不妨假设一开始有$2n+1$个人，显然标号为1的人恰好是在标号为$2n$的人后面被删除，剩下的是：
													![1567900301888](具体数学.assets/1567900301888.png)
我们再次得到与有n个人开始时几乎相同的情形，但是这一次他们的号码加倍并增加了1。从而：
$$
J(2n+1)=2J(n)+1，n\geq1.
$$
组合起来，我们就可以得到所有情形下$J$的递归式：
$$
\begin{align}
J(1)=&1;\\
J(2n)=&2J(n)-1,n\geq1;\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad(1.8)\\							
J(2n+1)=&2J(n)+1,n\geq1.
\end{align}
$$
这次不是由$J(n-1)$得到$J(n)$，但这个递归式要“有效”得多，因为每次用到它的时候，都会用2来缩减n。但我们仍然要寻找一个封闭形式，因为封闭形式计算起来更快，也蕴涵更丰富的信息。

有了递归式，我们可以对很小的值快速做出一张表：

|   n    |  1   | 2    |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |  11  |  12  |  13  |  14  | 15   |  16  |
| :----: | :--: | ---- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | ---- | :--: |
| $J(n)$ |  1   | 1    |  3   |  1   |  3   |  5   |  7   |  1   |  3   |  5   |  7   |  9   |  11  |  13  | 15   |  1   |

看来似乎可以按照2的幂将表中的数据分组，每一组的开始$J(n)$总是等于1，并且组里的数组每次递增2.因此我们将n写成$n=2^m+l$的形式，其中$2^m$是不超过n的2的最大幂，而$l$则是剩下的数，那么递增式的解看起来是：
$$
J(2^m+l)=2l+1,m\geq0,0\leq l<2^m.\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad(1.9)\\
注意：如果2^m\leq n<2^{m+1}，则余下来的数l=n-2^m满足0\leq l<2^{m+1}-2^m=2^m.
$$
现在给出式(1.9)的**证明**：
当$m=0$时必定有$l=0$，于是式(1.9)的基础就是$J(1)=1$，此结论为真。
归纳证明分成两个部分，按照$l$是偶数还是奇数而定。

1. 如果$m>0且2^m+l=2n$，那么$l$是偶数，又根据式(1.8)和归纳假设，有：
   $$
   J(2^m+l)=2J(2^{m-1}+l/2)-1=2(2l/2+1)-1=2l+1,
   $$

2. 如果$m>0且2^m+l=2n+1$，那么$l$是奇数，又根据式(1.8)和归纳假设，有：
   $$
   J(2^m+l)=2J(2^{m-1}+(l-1)/2)+1=2(2(l-1)/2+1)+1=2l+1
   $$

完成了归纳法，也就证明了式(1.9)。同时式(1.8)还蕴涵着关系式$J(2n+1)-J(2n)=2$。

**扩展及推广：**
我们在求解的过程中，2的幂起着重要的作用，所以自然要来研究$n$和$J(n)$的以2为基数的表示。假设$n$的二进制展开式是：
$$
n=(b_mb_{m-1}\cdots b_1b_0)_2,
$$
也就是说，
$$
n=b_m2^m+b_{m-1}2^{m-1}+\cdots+b_12+b_0,
$$
其中每个$b_i$为0或1，而首位数字$b_m$必须是1.注意$n=2^m+l$，我们依次就有
$$
\begin{align}
n=&(1b_{m-1}b_{m-2}\cdots b_1b_0)_2,\\
l=&(0b_{m-1}b_{m-2}\cdots b_1b_0)_2,\\
2l=&(b_{m-1}b_{m-2}\cdots b_1b_00)_2,\\
2l+1=&(b_{m-1}b_{m-2}\cdots b_1b_01)_2,\\
J(n)=&(b_{m-1}b_{m-2}\cdots b_1b_0b_m)_2.
\end{align}
$$
我们就证明了
$$
J((b_mb_{m-1}\cdots b_1b_0)_2)=(b_{m-1}\cdots b_1b_0b_m)_2.
$$
用计算机程序设计的方法说就是，**$n$向左循环移动一位就得到$J(n)$！**

如果我们从$n$开始，并对函数$J$迭代$m+1$次，那么就做了$m+1$次移位。由于$n$是一个$m+1$位的数，因此我们或许会期待再次得到$n$来结束循环。但是事实并不一定如此。例如：
				如果$n=13$，我们就有$J((1101)_2)=(1011)_2$，而此后却有$J((1011)_2)=(111)_2$。
故而该过程中断。当0成为首位时，它就会消失掉。

实际上，根据定义$J(n)$必定总是$\leq n$，这是因为$J(n)$是幸存者的号码；于是，如果$J(n)<n$，那么继续迭代下去永远也不可能回到$n$。重复运用$J$就会得到一列递减的值，它们最终到达一个“不动点”，在该点有$J(n)=n$。利用循环移位性质容易看出，不动点将是：对函数迭代足够多的次数总是会产生出全由1组成的形式，它的值是$2^{v(n)}-1$，其中$v(n)$是$n$的二进制表示中1的个数。于是，由于$v(13)=3$，我们有：
$$
\overbrace{J(J(···J}^{2个或者更多个J}(13)\cdots ))=2^3-1=7.
$$
类似地有
$$
\overbrace{J(J(\cdots J}^{8个或者更多个J}((101101101101011)_2)\cdots))=2^{10}-1=1023.
$$
结果令人惊奇，但正确无误。

让我们暂时回到第一个猜测：但$n$为偶数时有$J(n)=\frac n2$。它在一般情形下显然并不成立，不过现在我们可以确定它在什么情形下成立：
$$
\begin{align}
J(n)=&\frac n2,\\
2l+1=&(2^m+l)/2,\\
l=&\frac13(2^m-2).
\end{align}
$$
